diff --git a/programs/marginfi/tests/user_actions/liquidate_receiver.rs b/programs/marginfi/tests/user_actions/liquidate_receiver.rs
index b962fd26812a199887aff4f985974c968dd337d0..a4159a452d5d9fc42d5e5b86d3c1bc57b3b12901 100644
--- a/programs/marginfi/tests/user_actions/liquidate_receiver.rs
+++ b/programs/marginfi/tests/user_actions/liquidate_receiver.rs
@@ -1,19 +1,217 @@
-// TODO Set up tests where the liquidator always has the asset to repay, e.g. they can seize and
-// repay without restriction or need to swap at some third-party venue.
+use fixed_macro::types::I80F48;
+use fixtures::{assert_custom_error, prelude::*};
+use marginfi::{prelude::*, state::marginfi_account::MarginfiAccountImpl};
+use marginfi_type_crate::{
+    constants::LIQUIDATION_RECORD_SEED,
+    types::{BankConfigOpt, ACCOUNT_IN_RECEIVERSHIP},
+};
+use solana_program_test::*;
+use solana_sdk::{pubkey::Pubkey, signer::Signer, transaction::Transaction};
 
-// TODO happy path init liquidation record without permission. Health improves,
-// `liquidation_flat_sol_fee` is collected, and liquidator makes a profit. validate the liquidator
-// made a profit that is within the `liquidation_max_fee`
+#[tokio::test]
+async fn liquidate_start_fails_on_healthy_account() -> anyhow::Result<()> {
+    let test_f = TestFixture::new(Some(TestSettings::all_banks_payer_not_admin())).await;
+    let user = test_f.create_marginfi_account().await;
 
-// TODO happy path with a withdraw from several positions and/or repay to several positions.
+    let (record_pk, _bump) = Pubkey::find_program_address(
+        &[user.key.as_ref(), LIQUIDATION_RECORD_SEED.as_bytes()],
+        &marginfi::ID,
+    );
 
-// TODO happy path of liquidating a user who is unhealthy with liquidate_start and liquidate_end by
-// withdrawing some of their asset position and repaying some of their debt.
+    let init_ix = user.make_init_liquidation_record_ix(record_pk).await;
+    let start_ix = user
+        .make_start_liquidation_ix(record_pk, test_f.context.borrow().payer.pubkey())
+        .await;
 
-// TODO validate we cannot liquidate healthy accounts with liquidate_start
+    let mut ctx = test_f.context.borrow_mut();
+    // init the record first so Start can be sent alone
+    let init_tx = Transaction::new_signed_with_payer(
+        &[init_ix],
+        Some(&ctx.payer.pubkey()),
+        &[&ctx.payer],
+        ctx.last_blockhash,
+    );
+    ctx.banks_client.process_transaction(init_tx).await?;
 
-// TODO validate the various invariants in liquidate_start related to instruction introspection
-// (e.g. must be first, must be exclusive, end must be last, and only withdraw/repay/init record may
-// appear)
+    // Start on a healthy account should fail
+    let start_tx = Transaction::new_signed_with_payer(
+        &[start_ix],
+        Some(&ctx.payer.pubkey()),
+        &[&ctx.payer],
+        ctx.last_blockhash,
+    );
+    let res = ctx.banks_client.process_transaction(start_tx).await;
+    assert!(res.is_err());
+    assert_custom_error!(res.unwrap_err(), MarginfiError::HealthyAccount);
+    Ok(())
+}
 
-// TODO validate we cannot reduce the health of account when liquidating it
\ No newline at end of file
+#[tokio::test]
+async fn liquidate_start_must_be_first() -> anyhow::Result<()> {
+    let test_f = TestFixture::new(Some(TestSettings::all_banks_payer_not_admin())).await;
+
+    let liquidator = test_f.create_marginfi_account().await;
+    let liquidatee = test_f.create_marginfi_account().await;
+
+    let sol_bank = test_f.get_bank(&BankMint::Sol);
+    let usdc_bank = test_f.get_bank(&BankMint::Usdc);
+
+    let liq_token_account = test_f.usdc_mint.create_token_account_and_mint_to(100).await;
+    // leave 1 token for the later deposit in the failing tx
+    liquidator
+        .try_bank_deposit(liq_token_account.key, usdc_bank, 99.0, None)
+        .await?;
+
+    let user_token_sol = test_f.sol_mint.create_token_account_and_mint_to(1).await;
+    liquidatee
+        .try_bank_deposit(user_token_sol.key, sol_bank, 1.0, None)
+        .await?;
+    let user_token_usdc = test_f.usdc_mint.create_empty_token_account().await;
+    liquidatee
+        .try_bank_borrow(user_token_usdc.key, usdc_bank, 1.0)
+        .await?;
+
+    sol_bank
+        .update_config(
+            BankConfigOpt {
+                asset_weight_init: Some(I80F48!(0.25).into()),
+                asset_weight_maint: Some(I80F48!(0.5).into()),
+                ..Default::default()
+            },
+            None,
+        )
+        .await?;
+
+    let (record_pk, _bump) = Pubkey::find_program_address(
+        &[liquidatee.key.as_ref(), LIQUIDATION_RECORD_SEED.as_bytes()],
+        &marginfi::ID,
+    );
+
+    let init_ix = liquidatee.make_init_liquidation_record_ix(record_pk).await;
+    let deposit_ix = liquidator
+        .make_bank_deposit_ix(liq_token_account.key, usdc_bank, 1.0, None)
+        .await;
+    let start_ix = liquidatee
+        .make_start_liquidation_ix(record_pk, test_f.context.borrow().payer.pubkey())
+        .await;
+    let end_ix = liquidatee
+        .make_end_liquidation_ix(
+            record_pk,
+            test_f.context.borrow().payer.pubkey(),
+            test_f.marginfi_group.fee_state,
+            test_f.marginfi_group.fee_wallet,
+        )
+        .await;
+
+    let mut ctx = test_f.context.borrow_mut();
+    // init in a separate tx to isolate the StartNotFirst failure
+    let init_tx = Transaction::new_signed_with_payer(
+        &[init_ix],
+        Some(&ctx.payer.pubkey()),
+        &[&ctx.payer],
+        ctx.last_blockhash,
+    );
+    ctx.banks_client.process_transaction(init_tx).await?;
+
+    let tx = Transaction::new_signed_with_payer(
+        &[deposit_ix, start_ix, end_ix],
+        Some(&ctx.payer.pubkey()),
+        &[&ctx.payer],
+        ctx.last_blockhash,
+    );
+
+    let res = ctx.banks_client.process_transaction(tx).await;
+    assert!(res.is_err());
+    assert_custom_error!(res.unwrap_err(), MarginfiError::StartNotFirst);
+    Ok(())
+}
+
+#[tokio::test]
+async fn liquidate_receiver_happy_path() -> anyhow::Result<()> {
+    let mut test_f = TestFixture::new(Some(TestSettings::all_banks_payer_not_admin())).await;
+
+    let liquidator = test_f.create_marginfi_account().await;
+    let liquidatee = test_f.create_marginfi_account().await;
+
+    let sol_bank = test_f.get_bank(&BankMint::Sol);
+    let usdc_bank = test_f.get_bank(&BankMint::Usdc);
+
+    // liquidator provides initial liquidity and keeps some for repayment
+    let liq_usdc_account = test_f.usdc_mint.create_token_account_and_mint_to(7).await;
+    liquidator
+        .try_bank_deposit(liq_usdc_account.key, usdc_bank, 6.0, None)
+        .await?;
+
+    // setup liquidatee (after bank has liquidity)
+    let user_token_sol = test_f.sol_mint.create_token_account_and_mint_to(10).await;
+    let user_token_usdc = test_f.usdc_mint.create_empty_token_account().await;
+    liquidatee
+        .try_bank_deposit(user_token_sol.key, sol_bank, 10.0, None)
+        .await?;
+    liquidatee
+        .try_bank_borrow(user_token_usdc.key, usdc_bank, 5.0)
+        .await?;
+
+    // make account unhealthy
+    sol_bank
+        .update_config(
+            BankConfigOpt {
+                asset_weight_init: Some(I80F48!(0.25).into()),
+                asset_weight_maint: Some(I80F48!(0.5).into()),
+                ..Default::default()
+            },
+            None,
+        )
+        .await?;
+
+    let (record_pk, _bump) = Pubkey::find_program_address(
+        &[liquidatee.key.as_ref(), LIQUIDATION_RECORD_SEED.as_bytes()],
+        &marginfi::ID,
+    );
+
+    let init_ix = liquidatee.make_init_liquidation_record_ix(record_pk).await;
+    let start_ix = liquidatee
+        .make_start_liquidation_ix(record_pk, test_f.context.borrow().payer.pubkey())
+        .await;
+
+    // withdraw some sol to the liquidator and repay some usdc
+    let liq_sol_account = test_f.sol_mint.create_empty_token_account().await;
+    let withdraw_ix = liquidatee
+        .make_bank_withdraw_ix(liq_sol_account.key, sol_bank, 1.0, None)
+        .await;
+    let repay_ix = liquidator
+        .make_bank_repay_ix(liq_usdc_account.key, usdc_bank, 1.0, None)
+        .await;
+    let end_ix = liquidatee
+        .make_end_liquidation_ix(
+            record_pk,
+            test_f.context.borrow().payer.pubkey(),
+            test_f.marginfi_group.fee_state,
+            test_f.marginfi_group.fee_wallet,
+        )
+        .await;
+
+    let mut ctx = test_f.context.borrow_mut();
+    // initialize record separately so Start is first
+    let init_tx = Transaction::new_signed_with_payer(
+        &[init_ix],
+        Some(&ctx.payer.pubkey()),
+        &[&ctx.payer],
+        ctx.last_blockhash,
+    );
+    ctx.banks_client.process_transaction(init_tx).await?;
+
+    let tx = Transaction::new_signed_with_payer(
+        &[start_ix, withdraw_ix, repay_ix, end_ix],
+        Some(&ctx.payer.pubkey()),
+        &[&ctx.payer],
+        ctx.last_blockhash,
+    );
+
+    ctx.banks_client.process_transaction(tx).await?;
+
+    let liquidatee_ma = liquidatee.load().await;
+    assert_eq!(liquidatee_ma.get_flag(ACCOUNT_IN_RECEIVERSHIP), false);
+
+    Ok(())
+}
diff --git a/programs/marginfi/tests/user_actions/mod.rs b/programs/marginfi/tests/user_actions/mod.rs
index 820e3650999dc5d964d3e026fde76d37ad180bf1..f44fb83baa060b162d8c6fe11ee3f5bb172a8e7e 100644
--- a/programs/marginfi/tests/user_actions/mod.rs
+++ b/programs/marginfi/tests/user_actions/mod.rs
@@ -1,32 +1,33 @@
 mod borrow;
 mod close_account;
 mod close_balance;
 mod create_account;
 mod deposit;
 mod flash_loan;
 mod liquidate;
+mod liquidate_receiver;
 mod repay;
 mod withdraw;
 
 use anchor_lang::prelude::Clock;
 use fixed::types::I80F48;
 use fixtures::{assert_custom_error, assert_eq_noise, native, prelude::*};
 use marginfi::{
     assert_eq_with_tolerance,
     prelude::*,
     state::{bank::BankImpl, bank_config::BankConfigImpl, marginfi_account::BankAccountWrapper},
 };
 use marginfi_type_crate::constants::{
     EMISSIONS_FLAG_BORROW_ACTIVE, EMISSIONS_FLAG_LENDING_ACTIVE, MIN_EMISSIONS_START_TIME,
 };
 use pretty_assertions::assert_eq;
 use solana_program_test::*;
 use solana_sdk::timing::SECONDS_PER_YEAR;
 
 #[tokio::test]
 async fn automatic_interest_payments() -> anyhow::Result<()> {
     // Setup test executor with non-admin payer
     let test_f = TestFixture::new(Some(TestSettings::all_banks_payer_not_admin())).await;
 
     let usdc_bank_f = test_f.get_bank(&BankMint::Usdc);
     let sol_bank_f = test_f.get_bank(&BankMint::Sol);
diff --git a/test-utils/src/marginfi_account.rs b/test-utils/src/marginfi_account.rs
index 6990c62031b8038c7e0b666736c8332158cac25f..02fd818c6968178db19c2e29e138d0917c74cd01 100644
--- a/test-utils/src/marginfi_account.rs
+++ b/test-utils/src/marginfi_account.rs
@@ -829,26 +829,84 @@ impl MarginfiAccountFixture {
         let tx = Transaction::new_signed_with_payer(
             &[ComputeBudgetInstruction::set_compute_unit_price(nonce), ix],
             Some(&ctx.payer.pubkey().clone()),
             &[&ctx.payer],
             ctx.last_blockhash,
         );
 
         ctx.banks_client
             .process_transaction_with_preflight_and_commitment(tx, CommitmentLevel::Confirmed)
             .await
     }
 
     pub async fn nullify_assets_for_bank(&mut self, bank_pk: Pubkey) -> anyhow::Result<()> {
         let mut user_mfi_account: MarginfiAccount = self.load().await;
 
         let balance_index = user_mfi_account
             .lending_account
             .balances
             .iter()
             .position(|b| b.is_active() && b.bank_pk == bank_pk)
             .unwrap();
 
         user_mfi_account.lending_account.balances[balance_index].asset_shares = I80F48::ZERO.into();
         self.set_account(&user_mfi_account).await
     }
+
+    pub async fn make_start_liquidation_ix(
+        &self,
+        liquidation_record: Pubkey,
+        liquidation_receiver: Pubkey,
+    ) -> Instruction {
+        Instruction {
+            program_id: marginfi::ID,
+            accounts: marginfi::accounts::StartLiquidation {
+                marginfi_account: self.key,
+                liquidation_record,
+                liquidation_receiver,
+                instruction_sysvar: sysvar::instructions::id(),
+            }
+            .to_account_metas(Some(true)),
+            data: marginfi::instruction::StartLiquidation {}.data(),
+        }
+    }
+
+    pub async fn make_end_liquidation_ix(
+        &self,
+        liquidation_record: Pubkey,
+        liquidation_receiver: Pubkey,
+        fee_state: Pubkey,
+        global_fee_wallet: Pubkey,
+    ) -> Instruction {
+        Instruction {
+            program_id: marginfi::ID,
+            accounts: marginfi::accounts::EndLiquidation {
+                marginfi_account: self.key,
+                liquidation_record,
+                liquidation_receiver,
+                fee_state,
+                global_fee_wallet,
+                instruction_sysvar: sysvar::instructions::id(),
+                system_program: system_program::ID,
+            }
+            .to_account_metas(Some(true)),
+            data: marginfi::instruction::EndLiquidation {}.data(),
+        }
+    }
+
+    pub async fn make_init_liquidation_record_ix(
+        &self,
+        liquidation_record: Pubkey,
+    ) -> Instruction {
+        Instruction {
+            program_id: marginfi::ID,
+            accounts: marginfi::accounts::InitLiquidationRecord {
+                marginfi_account: self.key,
+                fee_payer: self.ctx.borrow().payer.pubkey(),
+                liquidation_record,
+                system_program: system_program::ID,
+            }
+            .to_account_metas(Some(true)),
+            data: marginfi::instruction::MarginfiAccountInitLiqRecord {}.data(),
+        }
+    }
 }
